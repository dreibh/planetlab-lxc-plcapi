#
# Functions for interacting with the nodes table in the database
#
# Mark Huang <mlhuang@cs.princeton.edu>
# Copyright (C) 2006 The Trustees of Princeton University
#
# $Id: Nodes.py,v 1.6 2006/10/02 15:21:03 mlhuang Exp $
#

from types import StringTypes
import re

from PLC.Faults import *
from PLC.Parameter import Parameter
from PLC.Debug import profile
from PLC.Table import Row, Table
from PLC.NodeNetworks import NodeNetwork, NodeNetworks
from PLC.BootStates import BootStates

class Node(Row):
    """
    Representation of a row in the nodes table. To use, optionally
    instantiate with a dict of values. Update as you would a
    dict. Commit to the database with sync().
    """

    fields = {
        'node_id': Parameter(int, "Node identifier"),
        'hostname': Parameter(str, "Fully qualified hostname", max = 255),
        'site_id': Parameter(int, "Site at which this node is located"),
        'boot_state': Parameter(str, "Boot state", max = 20),
        'model': Parameter(str, "Make and model of the actual machine", max = 255),
        'boot_nonce': Parameter(str, "(Admin only) Random value generated by the node at last boot", max = 128),
        'version': Parameter(str, "Apparent Boot CD version", max = 64),
        'ssh_rsa_key': Parameter(str, "Last known SSH host key", max = 1024),
        'date_created': Parameter(str, "Date and time when node entry was created"),
        'last_updated': Parameter(str, "Date and time when node entry was created"),
        'key': Parameter(str, "(Admin only) Node key", max = 256),
        'session': Parameter(str, "(Admin only) Node session value", max = 256),
        'nodenetwork_ids': Parameter([int], "List of network interfaces that this node has"),
        'nodegroup_ids': Parameter([int], "List of node groups that this node is in"),
        # 'conf_file_ids': Parameter([int], "List of configuration files specific to this node"),
        # 'root_person_ids': Parameter([int], "(Admin only) List of people who have root access to this node"),
        'slice_ids': Parameter([int], "List of slices on this node"),
        # 'pcu_ids': Parameter([int], "List of PCUs that control this node"),
        }

    def __init__(self, api, fields):
        Row.__init__(self, fields)
        self.api = api

    def validate_hostname(self, hostname):
        # 1. Each part begins and ends with a letter or number.
        # 2. Each part except the last can contain letters, numbers, or hyphens.
        # 3. Each part is between 1 and 64 characters, including the trailing dot.
        # 4. At least two parts.
        # 5. Last part can only contain between 2 and 6 letters.
        good_hostname = r'^([a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?\.)+' \
                        r'[a-z]{2,6}$'
        if not hostname or \
           not re.match(good_hostname, hostname, re.IGNORECASE):
            raise PLCInvalidArgument, "Invalid hostname"

        conflicts = Nodes(self.api, [hostname])
        for node_id, node in conflicts.iteritems():
            if 'node_id' not in self or self['node_id'] != node_id:
                raise PLCInvalidArgument, "Hostname already in use"

        # Check for conflicts with a nodenetwork hostname
        conflicts = NodeNetworks(self.api, [hostname])
        for nodenetwork_id in conflicts:
            if 'nodenetwork_ids' not in self or nodenetwork_id not in self['nodenetwork_ids']:
                raise PLCInvalidArgument, "Hostname already in use"

        return hostname

    def validate_boot_state(self, boot_state):
        if boot_state not in BootStates(self.api):
            raise PLCInvalidArgument, "Invalid boot state"

        return boot_state

    def sync(self, commit = True):
        """
        Flush changes back to the database.
        """

        self.validate()

        # Fetch a new node_id if necessary
        if 'node_id' not in self:
            rows = self.api.db.selectall("SELECT NEXTVAL('nodes_node_id_seq') AS node_id")
            if not rows:
                raise PLCDBError, "Unable to fetch new node_id"
            self['node_id'] = rows[0]['node_id']
            insert = True
        else:
            insert = False

        # Filter out fields that cannot be set or updated directly
        nodes_fields = self.api.db.fields('nodes')
        fields = dict(filter(lambda (key, value): key in nodes_fields,
                             self.items()))
        for ro_field in 'date_created', 'last_updated':
            if ro_field in fields:
                del fields[ro_field]

        # Parameterize for safety
        keys = fields.keys()
        values = [self.api.db.param(key, value) for (key, value) in fields.items()]

        if insert:
            # Insert new row in nodes table
            sql = "INSERT INTO nodes (%s) VALUES (%s)" % \
                  (", ".join(keys), ", ".join(values))
        else:
            # Update existing row in nodes table
            columns = ["%s = %s" % (key, value) for (key, value) in zip(keys, values)]
            sql = "UPDATE nodes SET " + \
                  ", ".join(columns) + \
                  " WHERE node_id = %(node_id)d"

        self.api.db.do(sql, fields)

        if commit:
            self.api.db.commit()

    def delete(self, commit = True):
        """
        Delete existing node.
        """

        assert 'node_id' in self

        # Delete all nodenetworks
        nodenetworks = NodeNetworks(self.api, self['nodenetwork_ids'])
        for nodenetwork in nodenetworks.values():
            nodenetwork.delete(commit = False)

        # Clean up miscellaneous join tables
        for table in ['nodegroup_node', 'slice_node', 'slice_attribute']:
            self.api.db.do("DELETE FROM %s" \
                           " WHERE node_id = %d" % \
                           (table, self['node_id']))

        # Mark as deleted
        self['deleted'] = True
        self.sync(commit)

class Nodes(Table):
    """
    Representation of row(s) from the nodes table in the
    database.
    """

    def __init__(self, api, node_id_or_hostname_list = None, fields = Node.fields.keys()):
        self.api = api

        sql = "SELECT %s FROM view_nodes WHERE deleted IS False" % \
              ", ".join(fields)

        if node_id_or_hostname_list:
            # Separate the list into integers and strings
            node_ids = filter(lambda node_id: isinstance(node_id, (int, long)),
                              node_id_or_hostname_list)
            hostnames = filter(lambda hostname: isinstance(hostname, StringTypes),
                               node_id_or_hostname_list)
            sql += " AND (False"
            if node_ids:
                sql += " OR node_id IN (%s)" % ", ".join(map(str, node_ids))
            if hostnames:
                sql += " OR hostname IN (%s)" % ", ".join(api.db.quote(hostnames)).lower()
            sql += ")"

        rows = self.api.db.selectall(sql)

        for row in rows:
            self[row['node_id']] = node = Node(api, row)
            for aggregate in ['nodenetwork_ids', 'nodegroup_ids',
                              'conf_file_ids', 'root_person_ids', 'slice_ids',
                              'pcu_ids']:
                if not node.has_key(aggregate) or node[aggregate] is None:
                    node[aggregate] = []
                else:
                    node[aggregate] = map(int, node[aggregate].split(','))
