<?xml version="1.0" encoding="UTF-8"?>
<!-- -*-xml-*- -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"@DOCBOOK-43@" [
<!ENTITY Methods SYSTEM "Methods.xml">
]>

<book>
  <bookinfo>
    <title>PlanetLab Central API Documentation</title>
  </bookinfo>

  <chapter id="Introduction">
    <title>Introduction</title>

    <para>The PlanetLab Central API (PLCAPI) is the interface through
    which the PlanetLab Central database should be accessed and
    maintained. The API is used by the website, by nodes, by automated
    scripts, and by users to access and update information about
    users, nodes, sites, slices, and other entities maintained by the
    database.</para>

    <section id="Authentication">
      <title>Authentication</title>

      <para>The API should be accessed via XML-RPC over HTTPS. The API
      supports the standard introspection calls <link
      linkend="system.listMethods">system.listMethods</link>, <link
      linkend="system.methodSignature">system.methodSignature</link>,
      and <link linkend="system.methodHelp">system.methodHelp</link>,
      and the standard batching call <link
      linkend="system.multicall">system.multicall</link>. With the
      exception of these calls, all PLCAPI calls take an
      authentication structure as their first argument. All
      authentication structures require the specification of
      <parameter>AuthMethod</parameter>. If the documentation for a
      call does not further specify the authentication structure, then
      any of (but only) the following authentication structures may be
      used:</para>

      <itemizedlist>
	<listitem>
	  <para>Session authentication. User sessions are typically
	  valid for 24 hours. Node sessions are valid until the next
	  reboot. Obtain a session key with <link
	  linkend="GetSession">GetSession</link> using another form of
	  authentication, such as password or GnuPG
	  authentication.</para>
	  <informaltable frame="none" rules="rows">
	    <tgroup cols="3">
	      <tbody>
		<row><entry>AuthMethod</entry><entry><literal>session</literal></entry></row>
		<row><entry>session</entry><entry>Session key</entry></row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</listitem>
	<listitem>
	  <para>Password authentication.</para>
	  <informaltable frame="none" rules="rows">
	    <tgroup cols="3">
	      <tbody>
		<row><entry>AuthMethod</entry><entry><literal>password</literal></entry></row>
		<row><entry>Username</entry><entry>Username, typically an e-mail address</entry></row>
		<row><entry>AuthString</entry><entry>Authentication string, typically a password</entry></row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</listitem>
	<listitem>
	  <para>GnuPG authentication. Users may upload a GPG public key
	  using <link linkend="AddPersonKey">AddPersonKey</link>. Peer
	  GPG keys should be added with <link
	  linkend="AddPeer">AddPeer</link> or <link
	  linkend="UpdatePeer">UpdatePeer</link>.
	  </para>
	  <informaltable frame="none" rules="rows">
	    <tgroup cols="3">
	      <tbody>
		<row><entry>AuthMethod</entry><entry><literal>gpg</literal></entry></row>
		<row><entry>name</entry><entry>Peer or user name</entry></row>
		<row><entry>signature</entry><entry>GnuPG signature of
		the <ulink
		url="http://www.w3.org/TR/xml-c14n">canonicalized</ulink>
		<ulink url="http://www.xmlrpc.com/spec">XML-RPC</ulink>
		representation of the rest of the arguments to the
		call.</entry></row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</listitem>
	<listitem>
	  <para>Anonymous authentication.</para>
	  <informaltable frame="none" rules="rows">
	    <tgroup cols="3">
	      <tbody>
		<row><entry>AuthMethod</entry><entry><literal>anonymous</literal></entry></row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	</listitem>
      </itemizedlist>
    </section>

    <section id="Roles">
      <title>Roles</title>

      <para>Some functions may only be called by users with certain
      roles (see <link linkend="GetRoles">GetRoles</link>), and others
      may return different information to different callers depending
      on the role(s) of the caller.</para>

      <para>The <literal>node</literal> and
      <literal>anonymous</literal> roles are pseudo-roles. A function
      that allows the <literal>node</literal> role may be called by
      automated scripts running on a node, such as the Boot and Node
      Managers. A function that allows the
      <literal>anonymous</literal> role may be called by anyone; an
      API authentication structure must still be specified (see <xref
      linkend="Authentication"/>).</para>
    </section>

    <section id="Filters">
      <title>Filters</title>

      <para>Most of the <function>Get</function> methods take a
      filter argument. Filters may be arrays of integer (and sometimes
      string) identifiers, or a struct representing a filter on the
      attributes of the entities being queried. For example,

<programlisting>
>>> GetNodes([1,2,3])
>>> GetNodes({'node_id': [1,2,3]})
</programlisting>
</para>

      <para>Would be equivalent queries. Attributes that are
      themselves arrays (such as <literal>interface_ids</literal>
      and <literal>slice_ids</literal> for nodes) cannot be used in
      filters.</para>

      <para> Filters support a few extra features illustrated in the following examples.</para>
      
      <section id="pattern-matching">
	<title> Pattern Matching</title>
	<para> <literal>*</literal> can be used in a text value and have the usual meaning, so all nodes in the <emphasis>fr</emphasis> can be obtained with:
	  <programlisting>GetNodes ( { 'hostname' : '*.fr' } ) </programlisting>
	</para>
      </section>

      <section id="negation">
	<title> Negation </title>
	<para> Fields starting with a <literal>~</literal> are negated, so non-local nodes can be fetched with:
	<programlisting>GetNodes( { '~peer_id' : None } ) </programlisting>
	</para>
      </section>

      <section id="numeric">
	<title> Nueric comparisons </title>
	<para> Strictly greater/smaller operations are achieved by prepending the field name like in:
	<programlisting>GetEvents( { '>time' : 1178531418 } ) </programlisting>
	</para>
	<para> Greater/smaller or equal: 
	<programlisting>GetEvents( { ']event_id' : 2305 } ) </programlisting>
	</para>
      </section>

      <section id="sort-clip">
	<title> Sorting and Clipping </title> 
	<para> The following 3 special fields can be used to extract only a subset of the results for pagination:
	  <programlisting> GetNodes( { '-SORT' : 'hostname' , '-OFFSET' : 30 , '-LIMIT' : 25 }</programlisting>
	</para>
      </section>
    </section>

    <section id="tags">
      <title>Tags</title>

      <para> The PLC API comes with a feature called
      <emphasis>tags</emphasis>, that basically aims at supporting an
      extensible data model. A few classes (as of this writing, Nodes,
      Interfaces and Slices) are eligible for being dynamically
      extended beyond the basic set of fields that are built into the
      database schema.</para>

      <para> Historically, this is a generalization of the concept of
      <emphasis> SliceAttribute </emphasis>, and the more recent
      concept of <emphasis> InterfaceSetting </emphasis>, that with
      release 5.0 have been renamed into <emphasis> SliceTag
      </emphasis> and <emphasis> InterfaceTag </emphasis>,
      respectively. </para>

      <section id="tags-low-level">
	<title> Low level </title>
	<para> The low level interface to tags relies on the following items:
      <itemizedlist>
	<listitem>
	  <para> 
	    A <emphasis> TagType </emphasis> object basically models a
	    new column that needs to be added to other objects. In
	    much the same way as nodes are named through a <emphasis>
	    hostname </emphasis>, tagtypes are named with a
	    <emphasis>tagname</emphasis>, plus additional information
	    (category, description) that is mostly informative. The
	    convention is to use a category that depicts the type of
	    objects that the tag type, like e.g. <emphasis>
	    node/config </emphasis> 
	  </para>
	</listitem>
	<listitem>
	  <para> You would then be allowed to attach a value to, say,
	  a Node, by calling <emphasis> AddNodeTag </emphasis>, and
	  then as usual change this value with <emphasis>
	  UpdateNodeTag </emphasis>, or delete it with <emphasis>
	  DeleteNodeTag </emphasis>. </para>
	</listitem>
      </itemizedlist>
    </para>
      </section>

      <section id="accessors">
	<title> Accessors </title>
      <para> A rather more convenient way to use tags is through
      Accessors. This convenience is located in <emphasis>
      PLC/Accessors </emphasis>, and allows you to easily define Get
      or Set methods dedicated to a given tag. This is for instance
      how the <emphasis> GetNodeArch </emphasis> and <emphasis>
      SetNodeArch </emphasis> methods are implemented. These methods
      greatly simplify tags manipulation as they take care of
      <itemizedlist>
	<listitem>
	  <para> Lazily create <emphasis> TagTypes </emphasis> when
	  needed,</para>
	</listitem>
	<listitem>
	  <para> Create or update the, say, <emphasis> NodeTag
	  </emphasis> object, as needed.</para>
	</listitem>
      </itemizedlist>
      </para>
      <para> <emphasis> Site-specific </emphasis> accessors can be
      defined in <emphasis>
      /usr/share/plc_api/PLC/Accessors/Accessors_site.py </emphasis>
      that will be preserved across updates of the PLCAPI rpm. 
      </para>
      <para> 
	This mechanism does not currently support setting slice
	tags that apply only on a given node or nodegroup. 
      </para>
      </section>

      <section id="expose-in-api">
	<title> Through regular Add/Get/Update methods </title>
      <para> 
	Finally, tags may also get manipulated through the
	<emphasis>AddNode</emphasis>, <emphasis>GetNodes</emphasis>,
	and <emphasis>UpdateNode</emphasis> methods:

      <itemizedlist>
	<listitem> <para> 
	  The <literal>define_accessors</literal> function in the
	  Accessors factory has an optional argument named <literal>
	  expose_in_api </literal>. When this is set, the
	  corresponding tag becomes visible from the Add/Get/Update
	  methods almost as if it was a native tag.
	</para> </listitem>

	<listitem><para>
	  So for instance the following code would be legal and do as expected:
<programlisting>
# create a x86_64 node
>>> AddNode({'hostname':'pl1.foo.com','arch':'x86_64'})
# get details for pl1.foo.com including tag 'arch' tag
>>> GetNodes(['pl1.foo.com'],['boot_state','node_type','arch'])
# set the 'deployment' tag
>>> UpdateNode('pl1.foo.com',{'deployment':'beta'})
# get all alpha and beta nodes
>>> GetNodes({'deployment':'*a'},['hostname','deployment'])
</programlisting>
	</para></listitem>

	<listitem><para> 
	  The current limitation about tags as opposed to native
	  fields is that, for performance, tags won't get returned
	  when using the implicit set of columns. So for instance:
<programlisting>
# get all details for 'pl1.foo.com' 
>>> node=GetNodes(['pl1.foo.com'])[0]
# this did not return the 'arch' tag
>>> 'arch' in node
False
</programlisting>
	</para></listitem>

      </itemizedlist>
    </para>
      </section>
    </section>

    <section id="nodegroups">
    <title>Nodegroups</title>

    <para> In earlier versions up to v4.2, <emphasis> NodeGroups
    </emphasis> used to be defined extensively. So you would,
    basically, create an empty nodegroup instance, and then use
    <emphasis> AddNodeToNodeGroup </emphasis> or <emphasis>
    DeleteNodeFromNodeGroup </emphasis> to manage the nodegroup's
    contents. </para>

    <para> The new model has been redefined as follows. You now define
    a nodegroup as the set of nodes for which a given <emphasis> Tag
    </emphasis> has a given value, which are defined once and for good
    when creating the <emphasis> NodeGroup </emphasis> object. </para>

    <para> So for instance for managing the set of nodes that are
    running various levels of software code, PLC has defined two
    <emphasis> NodeGroups </emphasis> named <literal> alpha </literal>
    and <literal> beta </literal>. With the new model, we would now do
    something like the following, using the built-in <literal>
    deployment </literal> tag that is created for that purpose:
<programlisting>
>>> AddNodeGroup('alphanodes','deployment','alpha')
21
>>> AddNodeGroup('betanodes','deployment','beta')
21
>>> for ng in GetNodeGroups(['alphanodes','betanodes'],['groupname','node_ids']): print ng
{'groupname': u'alphanodes', 'node_ids': []}
{'groupname': u'betanodes', 'node_ids': []}
>>> SetNodeDeployment('vnode01.inria.fr','alpha')
>>> for ng in GetNodeGroups(['alphanodes','betanodes'],['groupname','node_ids']): print ng
{'groupname': u'alphanodes', 'node_ids': [1]}
{'groupname': u'betanodes', 'node_ids': []}
>>> SetNodeDeployment('vnode01.inria.fr','beta')
>>> for ng in GetNodeGroups(['alphanodes','betanodes'],['groupname','node_ids']): print ng
{'groupname': u'alphanodes', 'node_ids': []}
{'groupname': u'betanodes', 'node_ids': [1]}
</programlisting>
</para>  

    </section>

    <section id="plcsh">
      <title>PlanetLab shell</title>

      <para>A command-line program called <command>plcsh</command>
      simplifies authentication structure handling, and is useful for
      scripting. This program is distributed as a Linux RPM called
      PLCAPI and requires Python &ge;2.4.</para>

      <programlisting>
usage: plcsh [options]

options:
  -f CONFIG, --config=CONFIG
                        PLC configuration file
  -h URL, --url=URL     API URL
  -c CACERT, --cacert=CACERT
                        API SSL certificate
  -k INSECURE, --insecure=INSECURE
                        Do not check SSL certificate
  -m METHOD, --method=METHOD
                        API authentication method
  -s SESSION, --session=SESSION
                        API session key
  -u USER, --user=USER  API user name
  -p PASSWORD, --password=PASSWORD
                        API password
  -r ROLE, --role=ROLE  API role
  -x, --xmlrpc          Use XML-RPC interface
  --help                show this help message and exit
      </programlisting>

      <para>Specify at least the API URL and your user name:</para>

      <programlisting>
plcsh --url https://www.planet-lab.org/PLCAPI/ -u user@site.edu
      </programlisting>

      <para>You will be presented with a prompt. From here, you can
      invoke API calls and omit the authentication structure, as it will
      be filled in automatically.</para>

      <programlisting>
user@site.edu connected using password authentication
Type "system.listMethods()" or "help(method)" for more information.
[user@site.edu]>>> AuthCheck()
1
[user@site.edu]>>> GetNodes([121], ['node_id', 'hostname'])
[{'node_id': 121, 'hostname': 'planetlab-1.cs.princeton.edu'}]
      </programlisting>

      <para>As this program is actually a Python interpreter, you may
      create variables, execute for loops, import other packages, etc.,
      directly on the command line as you would using the regular Python
      shell.</para>

      <para>To use <command>plcsh</command> programmatically, import
      the <function>PLC.Shell</function> module:</para>

      <programlisting>
#!/usr/bin/python

import sys

# Default location that the PLCAPI RPM installs the PLC class
sys.path.append('/usr/share/plc_api')

# Initialize shell environment. Shell() will define all PLCAPI methods
# in the specified namespace (specifying globals() will define them
# globally).
from PLC.Shell import Shell
plc = Shell(globals(),
            url = "https://www.planet-lab.org/PLCAPI/",
            user = "user@site.edu",
            password = "password")

# Both are equivalent
nodes = GetNodes([121], ['node_id', 'hostname'])
nodes = plc.GetNodes([121], ['node_id', 'hostname'])
      </programlisting>
    </section>
  </chapter>

  <chapter id="Methods">
    <title>PlanetLab API Methods</title>
    <para></para>

    &Methods;
  </chapter>

</book>

<!-- LocalWords:  PlanetLab API PLCAPI RPC HTTPS listMethods methodSignature
-->
<!-- LocalWords:  methodHelp multicall AuthMethod GetSession GnuPG Username GPG
-->
<!-- LocalWords:  AuthString AddPersonKey AddPeer UpdatePeer gpg
-->
